import { Network } from "@fogo/sessions-sdk";
import { PublicKey } from "@solana/web3.js";
import { install } from "@solana/webcrypto-ed25519-polyfill";
import type { DBSchema, IDBPObjectStore } from "idb";
import { openDB } from "idb";

install();

export const getStoredSession = async (
  network: Network,
  walletPublicKey: PublicKey,
) => {
  const session = await withStore("readonly", async (store) => {
    const value = await store.get(getCacheKey(network, walletPublicKey));
    if (
      value === undefined ||
      (value.sessionKey.publicKey instanceof CryptoKey &&
        value.sessionKey.privateKey instanceof CryptoKey)
    ) {
      return value;
    } else {
      console.warn(
        "The stored session key is not valid; this likely means it was generated by a ed25519 polyfill.  Ignoring stored value.",
      );
      return;
    }
  });
  return session
    ? { ...session, walletPublicKey: new PublicKey(session.walletPublicKey) }
    : undefined;
};

export const clearStoredSession = async (
  network: Network,
  walletPublicKey: PublicKey,
) =>
  withStore("readwrite", (store) =>
    store.delete(getCacheKey(network, walletPublicKey)),
  );

export const setStoredSession = async (
  network: Network,
  sessionData: Omit<StoredSession, "walletPublicKey"> & {
    walletPublicKey: PublicKey;
  },
) => {
  const serializedData = {
    ...sessionData,
    walletPublicKey: sessionData.walletPublicKey.toBase58(),
  };
  return withStore("readwrite", (store) =>
    store.put(
      serializedData,
      getCacheKey(network, sessionData.walletPublicKey),
    ),
  );
};

const withStore = async <Mode extends IDBTransactionMode, Output>(
  mode: Mode,
  cb: (
    store: IDBPObjectStore<SessionDBSchema, ["sessions"], "sessions", Mode>,
  ) => Promise<Output>,
): Promise<Output> => {
  const db = await openDB<SessionDBSchema>("sessionsdb", 1, {
    upgrade: (db) => db.createObjectStore("sessions"),
  });
  const tx = db.transaction("sessions", mode);
  const store = tx.objectStore("sessions");
  const ret = await cb(store);
  await tx.done;
  return ret;
};

const getCacheKey = (network: Network, wallet: PublicKey) =>
  `${wallet.toBase58()}:${NETWORK_TO_CACHE_KEY[network]}`;

const NETWORK_TO_CACHE_KEY: Record<Network, string> = {
  [Network.Mainnet]: "mainnet",
  [Network.Testnet]: "testnet",
};

type SessionDBSchema = DBSchema & {
  sessions: {
    key: string;
    value: StoredSession;
  };
};

type StoredSession = {
  sessionKey: CryptoKeyPair;
  walletPublicKey: string;
};
